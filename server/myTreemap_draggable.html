<!DOCTYPE html> <!-- From d3 website -->
<meta charset="utf-8">
<title>Treemap of LDA results</title>
				<!-- Need to add # and height 700->680-->
    <style>		
  	#chart {   				
			width: 1024px;
			height: 768px;
			background: #fff;
			margin: 10px;
			position: relative;
			-webkit-box-sizing: border-box;
				-moz-box-sizing: border-box;
					box-sizing: border-box;
		}
	
	.textdiv { /* text in the boxes */
			font-size: x-small;
			padding: 5px;
			font-family: "Open Sans", Helvetica, Arial, sans-serif; 
		}
		
	.dragging {
			strokeStyle: '#ff0000'
			
	rect {
			stroke: #fff;
			fill: #fff
		}
	}
	.cell {
	  border: solid 1px white;
	  font: 10px sans-serif;
	  line-height: 12px;
	  overflow: hidden;
	  position: absolute;
	  text-indent: 2px;
	}
	foreignObject {
			stroke-color: #000;
			stroke-width: 2px;
			margin: 2px
	}

    </style>

<html>
 <head>
	<script src="http://d3js.org/d3.v3.min.js"></script>
 </head>

 <body>           <!-- not necessary -->
 <p id="chart">   <!-- </p> not needed -->
  <script>
	var color = d3.scale.category20();
	var width = 960;
	var height = 680;
	var canvas = d3.select("#chart").append("svg")      // d3.select("body").append("svg"). // Need to add #
				.attr("width", width)
				.attr("height", height);
			
	d3.json("top_hier_data.json", function(root) { 
	
		var drag_vert = d3.behavior.drag()
//			.origin(Object)                             // (function(d) { return d; })
			.on("dragstart", dragstarted_vert)
			.on("drag", dragged_vert)
			.on("dragend", dragended_vert);

		var drag_hori = d3.behavior.drag()
			.on("dragstart", dragstarted_hori)
			.on("drag", dragged_hori)
			.on("dragend", dragended_hori);
			
		var treemap = d3.layout.treemap()
//				    .children(function(d, depth) { return depth ? null : d.children; })  // Only select the root
					.size([width, height])
//					.sort(function(a, b) { return a.value - b.value; })   // If sorting, we need to add ratio to make it more uniform.
//					.ratio(height / width * 0.5 * (1 + Math.sqrt(5)))
//					.sticky(true)
//					.round(false)
					.nodes(root)
//					.filter(function(d) { return d.children; })
					.filter(function(d) { return d.parent; });  // If remove this, also remove line 313 and 360.
		
		treemap.forEach(function(c) { 
			c.x2 = c.x + c.dx; 
			c.y2 = c.y + c.dy
		})
		console.log(root);
		console.log(treemap);
		console.log(treemap[1]);
		var vert_y = [];
		var hori_x = [];
		var vert_dx = [];
		var vert__dx = [];
		var hori_dy = [];
		var hori__dy = [];
		var cells = canvas.selectAll("*.cell")
					.data(treemap)
					.enter()
					.append("g")
					.attr("class", "cell")
		
		var topic_dom = cells.append("rect")
			.attr("x", function(d) { return d.x; })
			.attr("y", function(d) { return d.y; })
			.attr("width", function(d) { return d.dx; })
			.attr("height", function(d) { return d.dy; })
//			.attr("fill", function(d) { return d.children ? color(d.name) : null; })   // large rect with color, small rect with null. Larges is covered by smalls
			.attr("fill", function(d) { return d.parent ? color(d.parent.name) : null; }) // large rect with no color, small rect with d.parent.name
			.attr("stroke", "#000")		

		var topic_text = cells.append("text")
			.attr("x", function(d) { return d.x + 2; })
			.attr("y", function(d) { return d.y + 8; })
			.text(function(d) {var digit = Math.floor(d.dx / 6); return d.children ? null : d.name.substring(0,digit); })		
			.attr("class","textdiv");
/*	
		var topic_dom = cells.append("foreignObject")  // must append a "foreignObject"" to add html
				.attr("class","foreignobj")
//				.append("xhtml:div")   // adding this line will disable everything
//				.attr("dy", ".75em")
//				.text(function(d) { return d.children ? d.name : null; })
				.attr("x", function(d) { return d.x; })
				.attr("y", function(d) { return d.y; })
				.attr("width", function(d) { return d.dx; })
				.attr("height", function(d) { return d.dy; })
				.style("background", function(d) { return d.children ? color(d.name) : null; }) // Using background rather than fill
				.attr("stroke", "#fff")
				.html(function(d) { 
					if (0) {  // if (d.children) {
						return d.name + "<br>" + d.children[0].name + "<br>" + d.children[1].name + "<br>" + d.children[2].name + "<br>" + d.children[3].name + "<br>" + d.children[4].name;
					}
					else { return d.name; }
				//** The names on each block of main page and children pages
				})
				.attr("class","textdiv");  // make the texts look much better
*/
			console.log(topic_dom);

			root.children.forEach(function(c) {
//				console.log(c);
				
				var x2 = c.x + c.dx;
				var y2 = c.y + c.dy;
				if (vert_y[c.x] == null) { vert_y[c.x] = [c.y, y2]; }
				else { var arr = vert_y[c.x]; arr.push(c.y, y2); }   // BUG: push cannot function
				if (vert_y[x2] == null) { vert_y[x2] = [c.y, y2]; }
				else { var arr = vert_y[x2];  arr.push(c.y, y2); }
				if (hori_x[c.y] == null) { hori_x[c.y] = [c.x, x2]; }
				else { var arr = hori_x[c.y]; arr.push(c.x, x2); } 
				if (hori_x[y2] == null) { hori_x[y2] = [c.x, x2]; }
				else { var arr = hori_x[y2];  arr.push(c.x, x2); } 		
				
				if (vert_dx[c.x] == null) { vert_dx[c.x] = [c]; }
				else { var arr = vert_dx[c.x]; arr.push(c); }   // BUG: push cannot function
				if (vert__dx[x2] == null) { vert__dx[x2] = [c]; }
				else { var arr = vert__dx[x2];  arr.push(c); }
				if (hori_dy[c.y] == null) { hori_dy[c.y] = [c]; }
				else { var arr = hori_dy[c.y]; arr.push(c); } 
				if (hori__dy[y2] == null) { hori__dy[y2] = [c]; }
				else { var arr = hori__dy[y2];  arr.push(c); } 
			});
	
			var vert_line = [];         // Creating an array of data makes things easier
			var vert_dom;
			for (var k in vert_y) {
				var min_dx = Infinity;
				var min__dx = Infinity;
				var min_dx_rect = 0;
				var min__dx_rect = 0;
				
				var vert_dx_k = vert_dx[k];
				var vert__dx_k = vert__dx[k];
				
				if (k == 0) {
					vert_dx_k.forEach( function(c) {
						if (c.dx < min_dx) {
							min_dx = c.dx;
							min_dx_rect = c;
						}
					});	
				}
				else if (k == width) {
					vert__dx_k.forEach( function(c) {
						if (c.dx < min__dx) {
							min__dx = c.dx;
							min__dx_rect = c;
						}
					});
				}
				else {
					vert_dx_k.forEach( function(c) {
						if (c.dx < min_dx) {
							min_dx = c.dx;
							min_dx_rect = c;
						}
					});			
					vert__dx_k.forEach( function(c) {
						if (c.dx < min__dx) {
							min__dx = c.dx;
							min__dx_rect = c;
						}
					});
				}
				
			    if (k == 0) { 
				    vert_line.push([ k, Math.min.apply(null, vert_y[k]), k, Math.max.apply(null, vert_y[k]), 
									min_dx_rect, 0, treemap, topic_dom]);			// bind the root with data array rather than line (DOM)				
				} 
				else if (k == width) { 
				    vert_line.push([ k, Math.min.apply(null, vert_y[k]), k, Math.max.apply(null, vert_y[k]), 
									0, min__dx_rect, treemap, topic_dom ]);				
				}
				else { 
				    vert_line.push([ k, Math.min.apply(null, vert_y[k]), k, Math.max.apply(null, vert_y[k]), 
									min_dx_rect, min__dx_rect, treemap, topic_dom ]);		
				}
			}			
			var hori_line = [];         // Creating an array of data makes things easier
			var hori_dom;
			for (var k in hori_x) {
				var min_dy = Infinity;
				var min__dy = Infinity;
				var min_dy_rect = 0;
				var min__dy_rect = 0;
				
				var hori_dy_k = hori_dy[k];
				var hori__dy_k = hori__dy[k];
				
				if (k == 0) {
					hori_dy_k.forEach( function(c) {
						if (c.dy < min_dy) {
							min_dy = c.dy;
							min_dy_rect = c;
						}
					});	
				}
				else if (k == height) {
					hori__dy_k.forEach( function(c) {
						if (c.dy < min__dy) {
							min__dy = c.dy;
							min__dy_rect = c;
						}
					});
				}
				else {
					hori_dy_k.forEach( function(c) {
						if (c.dy < min_dy) {
							min_dy = c.dy;
							min_dy_rect = c;
						}
					});			
					hori__dy_k.forEach( function(c) {
						if (c.dy < min__dy) {
							min__dy = c.dy;
							min__dy_rect = c;
						}
					});
				}
			    if (k == 0) { 
				    hori_line.push([ Math.min.apply(null, hori_x[k]), k, Math.max.apply(null, hori_x[k]), k,  
									min_dy_rect, 0, treemap, topic_dom ]);			// bind the root with data array rather than line (DOM)				
				} 
				else if (k == height) { 
				    hori_line.push([ Math.min.apply(null, hori_x[k]), k, Math.max.apply(null, hori_x[k]), k, 
									0, min__dy_rect, treemap, topic_dom ]);				
				}
				else { 
				    hori_line.push([ Math.min.apply(null, hori_x[k]), k, Math.max.apply(null, hori_x[k]), k, 
									min_dy_rect, min__dy_rect, treemap, topic_dom ]);		
				}
			}
			console.log(vert_line);
			console.log(hori_line);
			
			vert_dom = canvas.selectAll("*.vert")
					.data(vert_line)
					.enter()
					.append("g")
					.attr("class", "vert")
					.append("line")
					.attr("x1", function(d) { return d[0]; })
					.attr("y1", function(d) { return d[1]; })
					.attr("x2", function(d) { return d[2]; })
					.attr("y2", function(d) { return d[3]; })
					.style("stroke", "black")
					.style("stroke-width", 3)
					.attr("cursor", "ew-resize")
					.call(drag_vert);
		
			hori_dom = canvas.selectAll("*.hori")
					.data(hori_line)
					.enter()
					.append("g")
					.attr("class", "hori")
					.append("line")
					.attr("x1", function(d) { return d[0]; })
					.attr("y1", function(d) { return d[1]; })
					.attr("x2", function(d) { return d[2]; })
					.attr("y2", function(d) { return d[3]; })
					.style("stroke", "black")
					.style("stroke-width", 3)
					.attr("cursor", "ns-resize")
					.call(drag_hori);
			for (var k in vert_line) {
				var vert_line_k = vert_line[k];
				vert_line_k.push(vert_line, vert_dom, hori_line, hori_dom, topic_text);
			}
			for (var k in hori_line) {
				var hori_line_k = hori_line[k];
				hori_line_k.push(vert_line, vert_dom, hori_line, hori_dom, topic_text);
			}
			console.log(hori_dom);
	})
	
	function dragstarted_vert(d) {
		d3.event.sourceEvent.stopPropagation();  // stop other actions
//		d3.select(this).classed("dragging", true);   // classing for styling
		d3.select(this).style("stroke", "red");
	}
	
	function dragstarted_hori(d) {
		d3.event.sourceEvent.stopPropagation();  // stop other actions
//		d3.select(this).classed("dragging", true);   // classing for styling
		d3.select(this).style("stroke", "red");
	}
	
	function dragged_vert(d) {  								// d is the binding data of the clicked line
		d3.select(this).attr("x1", d3.event.x)          	// Need to update our dataset simultaneously, or it will be reset by line 159, 161.
		               .attr("x2", d3.event.x);
		var old_line_x = parseFloat(d[0]);
		var new_line_x = parseFloat(d3.event.x);
		var buffer = parseFloat(0);
		console.log(d);
		if (d3.event.dx >= 0) {									// Move to the right side

			var left_rect = d[5];
			var left_line_x = parseFloat(left_rect.x);
			
			var expand = (isNaN(left_line_x)) ? 1: (new_line_x - left_line_x) / (old_line_x - left_line_x);
			var shrink = (old_line_x == width) ? 1: (width - new_line_x) / (width - old_line_x);

			d[6].forEach(function (c) {
				if (c.name == "LDA Topic Modeling") {
					c.x = c.x;
					c.x2 = c.x2;
					c.dx = c.dx;
				}
				else if (c.x + c.dx - buffer < old_line_x && c.x + c.dx + buffer > old_line_x && c.x - buffer < left_line_x && c.x + buffer > left_line_x) { // [M]
					c.x = c.x;
					c.x2 = new_line_x;
					c.dx = c.x2 - c.x;
				}
				else if (c.x + buffer >= old_line_x) {  // [2]
					c.x = width - (width - c.x) * shrink;
					c.x2 = width - (width - c.x2) * shrink;
					c.dx = c.x2 - c.x;
				}
				else if (c.x >= left_line_x && c.x + c.dx - buffer <= old_line_x) {  // [1]
					c.x = left_line_x + (+c.x - left_line_x) * expand;
					c.x2 = left_line_x + (+c.x2 - left_line_x) * expand;
					c.dx = c.x2 - c.x;
				}
				else if (c.x <= left_line_x && c.x + c.dx >= left_line_x && c.x + c.dx - buffer < old_line_x) {  // [3]
					c.x = c.x;
					c.x2 = left_line_x + (+c.x2 - left_line_x) * expand;
					c.dx = c.x2 - c.x;
				}
				else if (c.x >= left_line_x && c.x + c.dx + buffer >= old_line_x) {  // [4]
					c.x = left_line_x + (+c.x - left_line_x) * expand;
					c.x2 = width - (width - c.x2) * shrink;
					c.dx = c.x2 - c.x;
				}
				else if (c.x <= left_line_x && c.x + c.dx + buffer >= old_line_x) {  // [5]
					c.x = c.x;
					c.x2 = width - (width - c.x2) * shrink;
					c.dx = c.x2 - c.x;
				}
			});
			d[8].forEach(function (c, i) {   // Vertical line	
                // [0]-[7]: k, Math.min.apply(null, vert_y[k]), k, Math.max.apply(null, vert_y[k],
				// min_dx_rect, min__dx_rect, treemap, topic_dom,
                // [8]-[11]: vert_line, vert_dom, hori_line, hori_dom
						
				if (c == d3.select(this)) { }
				else if (+c[0] + buffer >= old_line_x) {
					c[0] = c[2] = width - (width - c[0]) * shrink;
				}
				else if (+c[0] - buffer <= old_line_x && +c[0] > left_line_x) {
				    c[0] = c[2] = left_line_x + (c[0] - left_line_x) * expand;
				}
			});
			d[10].forEach(function (c) {
				if (+c[0] + buffer >= old_line_x) {  // [2]
					c[0] = width - (width - c[0]) * shrink;
					c[2] = width - (width - c[2]) * shrink;
				}
				else if (+c[0] >= left_line_x && +c[2] - buffer <= old_line_x) {  // [1]
					c[0] = left_line_x + (+c[0] - left_line_x) * expand;
					c[2] = left_line_x + (+c[2] - left_line_x) * expand;
				}
				else if (+c[0] <= left_line_x && +c[2] >= left_line_x && +c[2] - buffer < old_line_x) {  // [3]
					c[0] = c[0];
					c[2] = left_line_x + (+c[2] - left_line_x) * expand;
				}
				else if (+c[0] >= left_line_x && +c[2] + buffer >= old_line_x) {  // [4]
				    c[0] = left_line_x + (+c[0] - left_line_x) * expand;
					c[2] = width - (width - c[2]) * shrink;
				}
				else if (+c[0] <= left_line_x && +c[2] + buffer >= old_line_x) {  // [5]
					c[0] = c[0];
					c[2] = width - (width - c[2]) * shrink;
				}			
			});
		}
		else {													// Move to the left side
			var right_rect = d[4];
			var right_line_x = parseFloat(right_rect.x) + parseFloat(right_rect.dx);	// bug: when not using parseFloat, they "sometimes" treated as strings
			var expand = (isNaN(right_line_x) ? 1: (right_line_x - new_line_x) / (right_line_x - old_line_x));
			var shrink = (old_line_x == 0) ? 1: d3.event.x / old_line_x;
			
			d[6].forEach(function (c) {
				if (c.name == "LDA Topic Modeling") {
					c.x = c.x;
					c.x2 = c.x2;
					c.dx = c.dx;
				}
				else if (c.x - buffer < old_line_x && c.x + buffer > old_line_x && c.x + c.dx - buffer < right_line_x && c.x + c.dx + buffer > right_line_x) {  // [M]
					c.x = new_line_x;
					c.x2 = c.x2;
					c.dx = c.x2 - c.x;
				}
				else if (c.x + c.dx - buffer <= old_line_x)  {		    		// [2] bug: when not setting up 10 as error space
				    c.x *= shrink; // x of each node does change, but rectangle does not change.		
					c.x2 *= shrink;
					c.dx = c.x2 - c.x;
				}
				else if (c.x + buffer >= old_line_x && c.x + c.dx <= right_line_x) {       // [1]
					c.x = right_line_x - (right_line_x - c.x) * expand;
					c.x2 = right_line_x - (right_line_x - c.x2) * expand;
					c.dx = c.x2 - c.x;
				}
				else if (c.x + buffer >= old_line_x && c.x < right_line_x && c.x + c.dx >= right_line_x) {   // [3] If not adding buffer, the rectangle will start moving later than the line
					c.x = right_line_x - (right_line_x - c.x) * expand;
					c.x2 = c.x2;
					c.dx = c.x2 - c.x;
				}
				else if (c.x - buffer < old_line_x && c.x + c.dx - buffer <= right_line_x) {  // [4]  // When moving to the left, in the end moving T0 will make T8 and T15 slightly wrong
					c.x *= shrink;
					c.x2 = right_line_x - (right_line_x - c.x2) * expand;
					c.dx = c.x2 - c.x;
				}
				else if (c.x - buffer < old_line_x && c.x + c.dx > right_line_x) {  // [5]
					c.x *= shrink;
					c.x2 = c.x2;
					c.dx = c.x2 - c.x;
				}
			});		
			d[8].forEach(function (c) {   // Vertical line	
                // [0]-[3]: k, Math.min.apply(null, vert_y[k]), k, Math.max.apply(null, vert_y[k],
				// [4]-[7]: min_dx_rect, min__dx_rect, treemap, topic_dom,
                // [8]-[12]: vert_line, vert_dom, hori_line, hori_dom, topic_text			
				if (c == d3.select(this)) { }
				else if (+c[0] - buffer <= old_line_x) {
					c[0] = c[2] = c[0] * shrink;
				}
				else if (+c[0] + buffer >= old_line_x && +c[0] < right_line_x) {
				    c[0] = c[2] = right_line_x - (right_line_x - c[0]) * expand;
				}
			});
			d[10].forEach(function (c) {
				if (+c[2] - buffer <= old_line_x)  {		    		// [2] bug: when not setting up 10 as error space
				    c[0] *= shrink; // x of each node does change, but rectangle does not change.		
					c[2] *= shrink;
				}
				else if (+c[0] + buffer >= old_line_x && +c[2] <= right_line_x) {       // [1]
					c[0] = right_line_x - (right_line_x - c[0]) * expand;
					c[2] = right_line_x - (right_line_x - c[2]) * expand;
				}
				else if (+c[0] + buffer >= old_line_x && +c[0] < right_line_x && +c[2] >= right_line_x) {   // [3] If not adding buffer, the rectangle will start moving later than the line
					c[0] = right_line_x - (right_line_x - c[0]) * expand;
					c[2] = c[2];
				}
				else if (+c[0] - buffer < old_line_x && +c[2] - buffer <= right_line_x) {  // [4]  // When moving to the left, in the end moving T0 will make T8 and T15 slightly wrong
					c[0] *= shrink;
					c[2] = right_line_x - (right_line_x - c[2]) * expand;
				}
				else if (+c[0] - buffer < old_line_x && +c[2] > right_line_x) {  // [5]
					c[0] *= shrink;
					c[2] = c[2];
				}			
			});
		}
		d[0] = d[2] = new_line_x;	// d3.event.x is changing within one call of dragged_vert  // Maybe undefined
	}
	
	function dragged_hori(d) {  								// d is the binding data of the clicked line
		d3.select(this).attr("y1", d3.event.y)          	// Need to update our dataset simultaneously, or it will be reset by line 159, 161.
		               .attr("y2", d3.event.y);
		var old_line_y = parseFloat(d[1]);
		var new_line_y = parseFloat(d3.event.y);
		var buffer = parseFloat(0);
		console.log(d);
		if (d3.event.dy >= 0) {									// Move to the right side

			var upper_rect = d[5];
			var upper_line_y = parseFloat(upper_rect.y);
			
			var expand = (isNaN(upper_line_y)) ? 1: (new_line_y - upper_line_y) / (old_line_y - upper_line_y);
			var shrink = (old_line_y == height) ? 1: (height - new_line_y) / (height - old_line_y);

			d[6].forEach(function (c) {
				if (c.name == "LDA Topic Modeling") {
					c.y = c.y;
					c.y2 = c.y2;
					c.dy = c.dy;
				}
				else if (c.y + c.dy - buffer < old_line_y && c.y + c.dy + buffer > old_line_y && c.y - buffer < upper_line_y && c.y + buffer > upper_line_y) { // [M]
					c.y = c.y;
					c.y2 = new_line_y;
					c.dy = c.y2 - c.y;
				}
				else if (c.y + buffer >= old_line_y) {  // [2]
					c.y = height - (height - c.y) * shrink;
					c.y2 = height - (height - c.y2) * shrink;
					c.dy = c.y2 - c.y;
				}
				else if (c.y >= upper_line_y && c.y + c.dy - buffer <= old_line_y) {  // [1]
					c.y = upper_line_y + (+c.y - upper_line_y) * expand;
					c.y2 = upper_line_y + (+c.y2 - upper_line_y) * expand;
					c.dy = c.y2 - c.y;
				}
				else if (c.y <= upper_line_y && c.y + c.dy >= upper_line_y && c.y + c.dy - buffer < old_line_y) {  // [3]
					c.y = c.y;
					c.y2 = upper_line_y + (+c.y2 - upper_line_y) * expand;
					c.dy = c.y2 - c.y;
				}
				else if (c.y >= upper_line_y && c.y + c.dy + buffer >= old_line_y) {  // [4]
					c.y = upper_line_y + (+c.y - upper_line_y) * expand;
					c.y2 = height - (height - c.y2) * shrink;
					c.dy = c.y2 - c.y;
				}
				else if (c.y <= upper_line_y && c.y + c.dy + buffer >= old_line_y) {  // [5]
					c.y = c.y;
					c.y2 = height - (height - c.y2) * shrink;
					c.dy = c.y2 - c.y;
				}
			});
			d[10].forEach(function (c, i) {   // Hroizontal line	
                // [0]-[7]: k, Math.min.apply(null, vert_y[k]), k, Math.max.apply(null, vert_y[k],
				// min_dx_rect, min__dx_rect, treemap, topic_dom,
                // [8]-[11]: vert_line, vert_dom, hori_line, hori_dom
						
				if (c == d3.select(this)) { }
				else if (+c[1] + buffer >= old_line_y) {
					c[1] = c[3] = height - (height - c[1]) * shrink;
				}
				else if (+c[1] - buffer <= old_line_y && +c[1] > upper_line_y) {
				    c[1] = c[3] = upper_line_y + (c[1] - upper_line_y) * expand;
				}
			});
			d[8].forEach(function (c) {
				if (+c[1] + buffer >= old_line_y) {  // [2]
					c[1] = height - (height - c[1]) * shrink;
					c[3] = height - (height - c[3]) * shrink;
				}
				else if (+c[1] >= upper_line_y && +c[3] - buffer <= old_line_y) {  // [1]
					c[1] = upper_line_y + (+c[1] - upper_line_y) * expand;
					c[3] = upper_line_y + (+c[3] - upper_line_y) * expand;
				}
				else if (+c[1] <= upper_line_y && +c[3] >= upper_line_y && +c[3] - buffer < old_line_y) {  // [3]
					c[1] = c[1];
					c[3] = upper_line_y + (+c[3] - upper_line_y) * expand;
				}
				else if (+c[1] >= upper_line_y && +c[3] + buffer >= old_line_y) {  // [4]
				    c[1] = upper_line_y + (+c[1] - upper_line_y) * expand;
					c[3] = height - (height - c[3]) * shrink;
				}
				else if (+c[1] <= upper_line_y && +c[3] + buffer >= old_line_y) {  // [5]
					c[1] = c[1];
					c[3] = height - (height - c[3]) * shrink;
				}			
			});
		}
		else {													// Move to the left side
			var lower_rect = d[4];
			var lower_line_y = parseFloat(lower_rect.y) + parseFloat(lower_rect.dy);	// bug: when not using parseFloat, they "sometimes" treated as strings
			var expand = (isNaN(lower_line_y) ? 1: (lower_line_y - new_line_y) / (lower_line_y - old_line_y));
			var shrink = (old_line_y == 0) ? 1: d3.event.y / old_line_y;
			
			d[6].forEach(function (c) {
				if (c.name == "LDA Topic Modeling") {
					c.y = c.y;
					c.y2 = c.y2;
					c.dy = c.dy;
				}
				else if (c.y - buffer < old_line_y && c.y + buffer > old_line_y && c.y + c.dy - buffer < lower_line_y && c.y + c.dy + buffer > lower_line_y) {  // [M]
					c.y = new_line_y;
					c.y2 = c.y2;
					c.dy = c.y2 - c.y;
				}
				else if (c.y + c.dy - buffer <= old_line_y)  {		    		// [2] bug: when not setting up 10 as error space
				    c.y *= shrink; // x of each node does change, but rectangle does not change.		
					c.y2 *= shrink;
					c.dy = c.y2 - c.y;
				}
				else if (c.y + buffer >= old_line_y && c.y + c.dy <= lower_line_y) {       // [1]
					c.y = lower_line_y - (lower_line_y - c.y) * expand;
					c.y2 = lower_line_y - (lower_line_y - c.y2) * expand;
					c.dy = c.y2 - c.y;
				}
				else if (c.y + buffer >= old_line_y && c.y < lower_line_y && c.y + c.dy >= lower_line_y) {   // [3] If not adding buffer, the rectangle will start moving later than the line
					c.y = lower_line_y - (lower_line_y - c.y) * expand;
					c.y2 = c.y2;
					c.dy = c.y2 - c.y;
				}
				else if (c.y - buffer < old_line_y && c.y + c.dy - buffer <= lower_line_y) {  // [4]  // When moving to the left, in the end moving T0 will make T8 and T15 slightly wrong
					c.y *= shrink;
					c.y2 = lower_line_y - (lower_line_y - c.y2) * expand;
					c.dy = c.y2 - c.y;
				}
				else if (c.y - buffer < old_line_y && c.y + c.dy > lower_line_y) {  // [5]
					c.y *= shrink;
					c.y2 = c.y2;
					c.dy = c.y2 - c.y;
				}
			});		
			d[10].forEach(function (c) {   // Horizontal line	
                // [0]-[3]: k, Math.min.apply(null, vert_y[k]), k, Math.max.apply(null, vert_y[k],
				// [4]-[7]: min_dx_rect, min__dx_rect, treemap, topic_dom,
                // [8]-[12]: vert_line, vert_dom, hori_line, hori_dom, topic_text			
				if (c == d3.select(this)) { }
				else if (+c[1] - buffer <= old_line_y) {
					c[1] = c[3] = c[1] * shrink;
				}
				else if (+c[1] + buffer >= old_line_y && +c[1] < lower_line_y) {
				    c[1] = c[3] = lower_line_y - (lower_line_y - c[1]) * expand;
				}
			});
			d[8].forEach(function (c) {    // Vertical line
				if (+c[3] - buffer <= old_line_y)  {		    		// [2] bug: when not setting up 10 as error space
				    c[1] *= shrink; // x of each node does change, but rectangle does not change.		
					c[3] *= shrink;
				}
				else if (+c[1] + buffer >= old_line_y && +c[3] <= lower_line_y) {       // [1]
					c[1] = lower_line_y - (lower_line_y - c[1]) * expand;
					c[3] = lower_line_y - (lower_line_y - c[3]) * expand;
				}
				else if (+c[1] + buffer >= old_line_y && +c[1] < lower_line_y && +c[3] >= lower_line_y) {   // [3] If not adding buffer, the rectangle will start moving later than the line
					c[1] = lower_line_y - (lower_line_y - c[1]) * expand;
					c[3] = c[3];
				}
				else if (+c[1] - buffer < old_line_y && +c[3] - buffer <= lower_line_y) {  // [4]  // When moving to the left, in the end moving T0 will make T8 and T15 slightly wrong
					c[1] *= shrink;
					c[3] = lower_line_y - (lower_line_y - c[3]) * expand;
				}
				else if (+c[1] - buffer < old_line_y && +c[3] > lower_line_y) {  // [5]
					c[1] *= shrink;
					c[3] = c[3];
				}			
			});
		}
		d[1] = d[3] = new_line_y;	// d3.event.x is changing within one call of dragged_vert  // Maybe undefined
	}
	
	function dragended_vert(d) {
//		d3.select(this).classed("dragging", false);
		d3.select(this).style("stroke", "black");
		d[7].attr("x", function (d) { return d.x; })    // rect_dom
			.attr("width", function (d) { return d.dx; });  // Can only use the data bound to this DOM, cannot use other var in the same space.
		d[9].attr("x1", function (d) { return d[0]; })  // vert_dom
			.attr("x2", function (d) { return d[2]; });
		d[11].attr("x1", function (d) { return d[0]; })  // hori_dom
			 .attr("x2", function (d) { return d[2]; });
		d[12].attr("x", function (d) { return d.x + 2; })  // topic_text
			 .text(function(d) {var digit = Math.floor(d.dx / 6); return d.children ? null : d.name.substring(0,digit); });		
	}
	
	function dragended_hori(d) {
//		d3.select(this).classed("dragging", false);
		d3.select(this).style("stroke", "black");
		d[7].attr("y", function (d) { return d.y; })    // rect_dom
			.attr("height", function (d) { return d.dy; });  // Can only use the data bound to this DOM, cannot use other var in the same space.
		d[9].attr("y1", function (d) { return d[1]; })  // vert_dom
			.attr("y2", function (d) { return d[3]; });
		d[11].attr("y1", function (d) { return d[1]; })  // hori_dom
			 .attr("y2", function (d) { return d[3]; });
		d[12].attr("y", function (d) { return d.y + 8; })  // topic_text
	}
	
   </script>
   </p>
   <p>
		<form>
		Number of topics:<br>
		<input type="text" name="num_topics">
		<br>
		Number of iterations:<br>
		<input type="text" name="num_iterations">
		</form>
   </p>
 </body>
</html>